### CNA创建项目工程

```pnpm
node  -v
// 原始创建方式
npx create-next-app@latest
// pnpm 方式
pnpm dlx create-next-app@latest

// 一步到位方式 npx/pnpm/.....
npx create-next-app@latest xxxxx --typescript --tailwind --eslint --app --src-dir --turbopack --import-alias "@/*"  --use-pnpm

// 注释代码
layout.tsx -- geistSans/geistMono  相关的代码
注释代码原因：因为如果我们网络在国内，这些字体来自于google，我们在国内的网络环境访问google将会受限，所有注释

// pnpm start 与 pnpm dev
```

### 文件系统路由

文件地址映射浏览器访问地址
路由/动态路由[id]

### Client Component 和 Server Component

#### 🔍 基本概念和工作原理

**Server Component (服务器组件)**

- 在服务器端渲染，HTML直接发送到浏览器
- 不包含客户端JavaScript逻辑
- 可以直接访问数据库、文件系统等服务器资源
- 默认所有组件都是Server Component

**Client Component (客户端组件)**

- 需要显式声明 `'use client';`
- 在浏览器中渲染和交互
- 可以使用React Hooks (useState, useEffect等)
- 可以访问浏览器API (window, document等)

#### 🚀 为什么Server Component更快？

1. **减少JavaScript包大小** - 服务器组件不会打包到客户端
2. **更快的首屏渲染** - HTML直接从服务器返回，无需等待JS执行
3. **更好的SEO** - 搜索引擎可以直接索引服务器渲染的内容
4. **减少网络请求** - 数据在服务器端获取，避免客户端API调用
5. **自动代码分割** - 只有需要的客户端代码才会发送到浏览器

#### 📝 渲染模式对比

| 特性           | Server Component | Client Component |
| -------------- | ---------------- | ---------------- |
| 渲染位置       | 服务器           | 浏览器           |
| 交互性         | 无               | 有               |
| Hooks支持      | ❌               | ✅               |
| 浏览器API      | ❌               | ✅               |
| 服务器资源访问 | ✅               | ❌               |
| Bundle大小     | 0                | 计入bundle       |
| 首屏速度       | 快               | 相对慢           |

#### 🌐 Blog案例对比

**访问路径**: `http://localhost:3000/blog/[id]`

**Server Component 示例 (推荐用于数据展示)**

```tsx
// app/blog/[id]/page.tsx - Server Component
interface BlogPost {
  id: string;
  title: string;
  content: string;
  author: string;
  publishedAt: string;
}

// 直接在服务器获取数据
async function getBlogPost(id: string): Promise<BlogPost> {
  // 模拟数据库查询 - 在服务器端执行
  const response = await fetch(`${process.env.API_URL}/posts/${id}`, {
    cache: 'force-cache', // 服务器端缓存
  });
  return response.json();
}

// 服务器组件 - 默认行为，无需 'use client'
export default async function BlogPage({ params }: { params: { id: string } }) {
  // 服务器端数据获取
  const post = await getBlogPost(params.id);

  return (
    <article className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-4">{post.title}</h1>
      <div className="text-gray-600 mb-6">
        作者: {post.author} | 发布时间: {post.publishedAt}
      </div>
      <div className="prose max-w-none">{post.content}</div>
    </article>
  );
}
```

**Client Component 示例 (用于交互功能)**

```tsx
// components/BlogInteractions.tsx - Client Component
'use client';

// 必须声明
import { useEffect, useState } from 'react';

// components/BlogInteractions.tsx - Client Component

// components/BlogInteractions.tsx - Client Component

// components/BlogInteractions.tsx - Client Component

// components/BlogInteractions.tsx - Client Component

// components/BlogInteractions.tsx - Client Component

interface BlogInteractionsProps {
  postId: string;
}

export default function BlogInteractions({ postId }: BlogInteractionsProps) {
  const [likes, setLikes] = useState(0);
  const [comments, setComments] = useState([]);
  const [isLiked, setIsLiked] = useState(false);

  // 客户端数据获取
  useEffect(() => {
    fetch(`/api/blog/${postId}/stats`)
      .then(res => res.json())
      .then(data => {
        setLikes(data.likes);
        setComments(data.comments);
      });
  }, [postId]);

  const handleLike = async () => {
    setIsLiked(!isLiked);
    setLikes(prev => (isLiked ? prev - 1 : prev + 1));

    await fetch(`/api/blog/${postId}/like`, {
      method: 'POST',
      body: JSON.stringify({ action: isLiked ? 'unlike' : 'like' }),
    });
  };

  return (
    <div className="mt-8 border-t pt-6">
      {/* 点赞功能 */}
      <button
        onClick={handleLike}
        className={`flex items-center gap-2 px-4 py-2 rounded ${
          isLiked ? 'bg-red-500 text-white' : 'bg-gray-100'
        }`}
      >
        ❤️ {likes} 点赞
      </button>

      {/* 评论区域 */}
      <div className="mt-6">
        <h3 className="text-xl font-semibold mb-4">评论 ({comments.length})</h3>
        {/* 评论列表和输入框 */}
      </div>
    </div>
  );
}
```

#### 🏗️ 混合使用模式

```tsx
// app/blog/[id]/page.tsx - 完整示例
import BlogInteractions from '@/components/BlogInteractions';

// Server Component (主体)
export default async function BlogPage({ params }: { params: { id: string } }) {
  // 服务器端数据获取 - 快速首屏渲染
  const post = await getBlogPost(params.id);

  return (
    <div className="max-w-4xl mx-auto p-6">
      {/* 服务器渲染的静态内容 */}
      <article>
        <h1 className="text-3xl font-bold mb-4">{post.title}</h1>
        <div className="text-gray-600 mb-6">
          作者: {post.author} | 发布时间: {post.publishedAt}
        </div>
        <div className="prose max-w-none">{post.content}</div>
      </article>

      {/* 客户端组件 - 处理交互 */}
      <BlogInteractions postId={params.id} />
    </div>
  );
}
```

#### 💡 最佳实践

1. **默认使用Server Component** - 除非需要交互功能
2. **数据获取在Server Component** - 利用服务器端性能
3. **交互功能用Client Component** - 表单、按钮、动画等
4. **组件边界清晰** - Server和Client组件职责分明
5. **混合使用** - Server Component包含Client Component

### hooks

只能在client component中使用，如：useState....

案例：useParams

# Resend邮件

### Route Handlers and Middleware
