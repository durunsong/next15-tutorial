import { Callout, Steps, Tabs, Tab } from 'nextra/components'

# Redis ç¼“å­˜æ•™ç¨‹

<Callout type="info" emoji="âš¡">
æœ¬æ•™ç¨‹å°†æ•™ä½ å¦‚ä½•åœ¨ Next.js é¡¹ç›®ä¸­ä½¿ç”¨ Redis è¿›è¡Œç¼“å­˜ï¼Œæå‡åº”ç”¨æ€§èƒ½ã€‚
</Callout>

## ä¸ºä»€ä¹ˆä½¿ç”¨ Redisï¼Ÿ

Redis æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„å†…å­˜æ•°æ®åº“ï¼Œåœ¨ Web åº”ç”¨ä¸­ä¸»è¦ç”¨äºï¼š

- **ç¼“å­˜** - å‡å°‘æ•°æ®åº“æŸ¥è¯¢ï¼Œæå‡å“åº”é€Ÿåº¦
- **ä¼šè¯å­˜å‚¨** - å­˜å‚¨ç”¨æˆ·ä¼šè¯ä¿¡æ¯
- **é™æµ** - å®ç° API é™æµåŠŸèƒ½
- **æ¶ˆæ¯é˜Ÿåˆ—** - å¤„ç†å¼‚æ­¥ä»»åŠ¡
- **å®æ—¶æ•°æ®** - å­˜å‚¨å®æ—¶ç»Ÿè®¡æ•°æ®

## é¡¹ç›®ä¸­çš„ Redis é…ç½®

æˆ‘ä»¬ä½¿ç”¨ Upstash Redis ä½œä¸ºäº‘ Redis æœåŠ¡ï¼š

```typescript filename="lib/redis.ts" {1-11}
import { Redis } from '@upstash/redis'

if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
  throw new Error('UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN must be defined')
}

export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL,
  token: process.env.UPSTASH_REDIS_REST_TOKEN,
})
```

## ç¼“å­˜ç®¡ç†å·¥å…·ç±»

æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªç±»å‹å®‰å…¨çš„ç¼“å­˜ç®¡ç†å·¥å…·ç±»ï¼š

<Tabs items={['åŸºç¡€æ“ä½œ', 'é«˜çº§åŠŸèƒ½', 'é”™è¯¯å¤„ç†']}>
  <Tab>
    ```typescript filename="lib/redis.ts" {13-42}
    export class CacheManager {
      // è·å–ç¼“å­˜
      static async get<T>(key: string): Promise<T | null> {
        try {
          const data = await redis.get(key)
          return data as T
        } catch (error) {
          console.error('Redis get error:', error)
          return null
        }
      }

      // è®¾ç½®ç¼“å­˜
      static async set<T>(
        key: string, 
        value: T, 
        options?: { ex?: number; px?: number }
      ): Promise<boolean> {
        try {
          if (options?.ex) {
            await redis.set(key, value, { ex: options.ex })
          } else if (options?.px) {
            await redis.set(key, value, { px: options.px })
          } else {
            await redis.set(key, value)
          }
          return true
        } catch (error) {
          console.error('Redis set error:', error)
          return false
        }
      }

      // åˆ é™¤ç¼“å­˜
      static async del(key: string): Promise<boolean> {
        try {
          await redis.del(key)
          return true
        } catch (error) {
          console.error('Redis del error:', error)
          return false
        }
      }
    }
    ```
  </Tab>
  <Tab>
    ```typescript filename="lib/redis.ts" {44-91}
    export class CacheManager {
      // ... åŸºç¡€æ“ä½œ

      // æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
      static async exists(key: string): Promise<boolean> {
        try {
          const result = await redis.exists(key)
          return result === 1
        } catch (error) {
          console.error('Redis exists error:', error)
          return false
        }
      }

      // è·å–é”®çš„è¿‡æœŸæ—¶é—´
      static async ttl(key: string): Promise<number> {
        try {
          return await redis.ttl(key)
        } catch (error) {
          console.error('Redis ttl error:', error)
          return -1
        }
      }

      // åŸå­é€’å¢
      static async increment(key: string, amount: number = 1): Promise<number> {
        try {
          return await redis.incrby(key, amount)
        } catch (error) {
          console.error('Redis increment error:', error)
          return 0
        }
      }

      // è®¾ç½®è¿‡æœŸæ—¶é—´
      static async expire(key: string, seconds: number): Promise<boolean> {
        try {
          const result = await redis.expire(key, seconds)
          return result === 1
        } catch (error) {
          console.error('Redis expire error:', error)
          return false
        }
      }
    }
    ```
  </Tab>
  <Tab>
    ```typescript filename="lib/redis.ts"
    // å¸¦é‡è¯•æœºåˆ¶çš„ç¼“å­˜æ“ä½œ
    export class CacheManager {
      private static async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries: number = 3
      ): Promise<T | null> {
        for (let i = 0; i < maxRetries; i++) {
          try {
            return await operation()
          } catch (error) {
            console.warn(`Redis operation failed, retry ${i + 1}/${maxRetries}:`, error)
            if (i === maxRetries - 1) {
              console.error('Redis operation failed after all retries:', error)
              return null
            }
            // æŒ‡æ•°é€€é¿å»¶è¿Ÿ
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 100))
          }
        }
        return null
      }

      // å¸¦é‡è¯•çš„è·å–æ“ä½œ
      static async getWithRetry<T>(key: string): Promise<T | null> {
        return this.retryOperation(() => redis.get(key)) as Promise<T | null>
      }

      // å¸¦é‡è¯•çš„è®¾ç½®æ“ä½œ
      static async setWithRetry<T>(
        key: string, 
        value: T, 
        options?: { ex?: number }
      ): Promise<boolean> {
        const result = await this.retryOperation(() => 
          redis.set(key, value, options)
        )
        return result !== null
      }
    }
    ```
  </Tab>
</Tabs>

## å®é™…åº”ç”¨åœºæ™¯

### 1. æ•°æ®åº“æŸ¥è¯¢ç¼“å­˜

<Steps>

### åˆ›å»ºç¼“å­˜åŒ…è£…å‡½æ•°

```typescript filename="lib/cache-helpers.ts"
import { CacheManager } from './redis'
import { prisma } from './prisma'

// é€šç”¨ç¼“å­˜åŒ…è£…å‡½æ•°
export async function withCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = 300 // é»˜è®¤5åˆ†é’Ÿ
): Promise<T> {
  // å°è¯•ä»ç¼“å­˜è·å–
  const cached = await CacheManager.get<T>(key)
  if (cached !== null) {
    console.log(`Cache hit for key: ${key}`)
    return cached
  }

  // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“è·å–
  console.log(`Cache miss for key: ${key}`)
  const data = await fetcher()
  
  // å­˜å…¥ç¼“å­˜
  await CacheManager.set(key, data, { ex: ttl })
  return data
}
```

### åº”ç”¨åˆ°ç”¨æˆ·æŸ¥è¯¢

```typescript filename="app/api/users/[id]/route.ts" {8-20}
import { withCache } from '@/lib/cache-helpers'

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const userId = params.id
    
    // ä½¿ç”¨ç¼“å­˜åŒ…è£…å™¨
    const user = await withCache(
      `user:${userId}`,
      async () => {
        return await prisma.user.findUnique({
          where: { id: userId },
          select: {
            id: true,
            email: true,
            username: true,
            avatar: true,
            createdAt: true,
          }
        })
      },
      600 // ç¼“å­˜10åˆ†é’Ÿ
    )
    
    if (!user) {
      return NextResponse.json(
        { error: 'ç”¨æˆ·ä¸å­˜åœ¨' },
        { status: 404 }
      )
    }
    
    return NextResponse.json(user)
  } catch (error) {
    console.error('æŸ¥è¯¢ç”¨æˆ·å¤±è´¥:', error)
    return NextResponse.json(
      { error: 'æœåŠ¡å™¨é”™è¯¯' },
      { status: 500 }
    )
  }
}
```

### ç¼“å­˜å¤±æ•ˆç­–ç•¥

```typescript filename="app/api/users/[id]/route.ts"
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const userId = params.id
    const updateData = await req.json()
    
    // æ›´æ–°æ•°æ®åº“
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      select: {
        id: true,
        email: true,
        username: true,
        avatar: true,
        updatedAt: true,
      }
    })
    
    // åˆ é™¤ç›¸å…³ç¼“å­˜
    await Promise.all([
      CacheManager.del(`user:${userId}`),
      CacheManager.del(`user:profile:${userId}`),
      CacheManager.del('users:list'), // å¦‚æœæœ‰ç”¨æˆ·åˆ—è¡¨ç¼“å­˜
    ])
    
    return NextResponse.json(updatedUser)
  } catch (error) {
    console.error('æ›´æ–°ç”¨æˆ·å¤±è´¥:', error)
    return NextResponse.json(
      { error: 'æœåŠ¡å™¨é”™è¯¯' },
      { status: 500 }
    )
  }
}
```

</Steps>

### 2. API é™æµ

å®ç°åŸºäº Redis çš„ API é™æµï¼š

```typescript filename="lib/rate-limit.ts"
import { CacheManager } from './redis'

export interface RateLimitConfig {
  interval: number // æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
  limit: number    // è¯·æ±‚é™åˆ¶æ•°é‡
}

export class RateLimiter {
  static async checkLimit(
    identifier: string,
    config: RateLimitConfig
  ): Promise<{
    allowed: boolean
    remaining: number
    resetTime: number
  }> {
    const key = `rate_limit:${identifier}`
    const now = Date.now()
    const window = Math.floor(now / (config.interval * 1000))
    const windowKey = `${key}:${window}`
    
    try {
      // è·å–å½“å‰çª—å£çš„è¯·æ±‚æ•°é‡
      const current = await CacheManager.get<number>(windowKey) || 0
      
      if (current >= config.limit) {
        const resetTime = (window + 1) * config.interval * 1000
        return {
          allowed: false,
          remaining: 0,
          resetTime
        }
      }
      
      // é€’å¢è®¡æ•°å™¨
      const newCount = await CacheManager.increment(windowKey)
      
      // è®¾ç½®è¿‡æœŸæ—¶é—´
      await CacheManager.expire(windowKey, config.interval)
      
      const resetTime = (window + 1) * config.interval * 1000
      return {
        allowed: true,
        remaining: Math.max(0, config.limit - newCount),
        resetTime
      }
    } catch (error) {
      console.error('Rate limit check failed:', error)
      // åœ¨ Redis é”™è¯¯æ—¶å…è®¸è¯·æ±‚é€šè¿‡
      return {
        allowed: true,
        remaining: config.limit - 1,
        resetTime: now + config.interval * 1000
      }
    }
  }
}
```

### 3. ä¼šè¯ç®¡ç†

ä½¿ç”¨ Redis å­˜å‚¨ç”¨æˆ·ä¼šè¯ï¼š

```typescript filename="lib/session.ts"
import { CacheManager } from './redis'
import { randomBytes } from 'crypto'

export interface Session {
  userId: string
  username: string
  email: string
  createdAt: number
  lastActivity: number
}

export class SessionManager {
  private static readonly SESSION_TTL = 7 * 24 * 60 * 60 // 7å¤©

  // åˆ›å»ºä¼šè¯
  static async createSession(user: {
    id: string
    username: string
    email: string
  }): Promise<string> {
    const sessionId = randomBytes(32).toString('hex')
    const session: Session = {
      userId: user.id,
      username: user.username,
      email: user.email,
      createdAt: Date.now(),
      lastActivity: Date.now(),
    }
    
    await CacheManager.set(
      `session:${sessionId}`,
      session,
      { ex: this.SESSION_TTL }
    )
    
    return sessionId
  }

  // è·å–ä¼šè¯
  static async getSession(sessionId: string): Promise<Session | null> {
    const session = await CacheManager.get<Session>(`session:${sessionId}`)
    
    if (session) {
      // æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
      session.lastActivity = Date.now()
      await CacheManager.set(
        `session:${sessionId}`,
        session,
        { ex: this.SESSION_TTL }
      )
    }
    
    return session
  }

  // åˆ é™¤ä¼šè¯
  static async deleteSession(sessionId: string): Promise<void> {
    await CacheManager.del(`session:${sessionId}`)
  }

  // æ¸…é™¤ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯
  static async clearUserSessions(userId: string): Promise<void> {
    // æ³¨æ„ï¼šè¿™éœ€è¦ Redis SCAN å‘½ä»¤æ¥æŸ¥æ‰¾æ‰€æœ‰ä¼šè¯
    // åœ¨å®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦ç»´æŠ¤ä¸€ä¸ªç”¨æˆ·->ä¼šè¯IDçš„æ˜ å°„
  }
}
```

## ç¼“å­˜ç­–ç•¥

### 1. Cache-Aside æ¨¡å¼

```typescript filename="æœåŠ¡å±‚ç¼“å­˜æ¨¡å¼"
export class UserService {
  static async getUserById(id: string) {
    // 1. æ£€æŸ¥ç¼“å­˜
    const cachedUser = await CacheManager.get<User>(`user:${id}`)
    if (cachedUser) {
      return cachedUser
    }
    
    // 2. ä»æ•°æ®åº“è·å–
    const user = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        username: true,
        email: true,
        avatar: true,
      }
    })
    
    // 3. å†™å…¥ç¼“å­˜
    if (user) {
      await CacheManager.set(`user:${id}`, user, { ex: 600 })
    }
    
    return user
  }
  
  static async updateUser(id: string, data: Partial<User>) {
    // 1. æ›´æ–°æ•°æ®åº“
    const updatedUser = await prisma.user.update({
      where: { id },
      data,
    })
    
    // 2. åˆ é™¤ç¼“å­˜ï¼ˆè®©ä¸‹æ¬¡æŸ¥è¯¢é‡æ–°åŠ è½½ï¼‰
    await CacheManager.del(`user:${id}`)
    
    return updatedUser
  }
}
```

### 2. Write-Through æ¨¡å¼

```typescript filename="åŒæ­¥å†™å…¥ç¼“å­˜"
export class PostService {
  static async createPost(data: CreatePostData) {
    // 1. å†™å…¥æ•°æ®åº“
    const post = await prisma.post.create({
      data,
      include: {
        author: {
          select: {
            username: true,
            avatar: true,
          }
        }
      }
    })
    
    // 2. åŒæ—¶å†™å…¥ç¼“å­˜
    await CacheManager.set(`post:${post.id}`, post, { ex: 1800 })
    
    // 3. æ¸…é™¤åˆ—è¡¨ç¼“å­˜
    await CacheManager.del('posts:latest')
    
    return post
  }
}
```

### 3. Write-Behind æ¨¡å¼

```typescript filename="å¼‚æ­¥å†™å…¥æ•°æ®åº“"
export class ViewCountService {
  static async incrementView(postId: string) {
    // 1. ç«‹å³æ›´æ–° Redis è®¡æ•°å™¨
    const newCount = await CacheManager.increment(`views:${postId}`)
    
    // 2. å¼‚æ­¥æ‰¹é‡æ›´æ–°æ•°æ®åº“ï¼ˆå¯ä»¥ä½¿ç”¨é˜Ÿåˆ—ï¼‰
    if (newCount % 10 === 0) { // æ¯10æ¬¡æµè§ˆé‡æ›´æ–°ä¸€æ¬¡æ•°æ®åº“
      await prisma.post.update({
        where: { id: postId },
        data: { views: newCount }
      })
    }
    
    return newCount
  }
}
```

## Redis å®é™…æ¼”ç¤º

### æµ‹è¯• Redis åŠŸèƒ½

è®¿é—® [Redis æµ‹è¯•é¡µé¢](/redis-test) æŸ¥çœ‹ä»¥ä¸‹åŠŸèƒ½çš„å®é™…æ¼”ç¤ºï¼š

1. **åŸºç¡€æ“ä½œ** - è®¾ç½®ã€è·å–ã€åˆ é™¤é”®å€¼
2. **è¿‡æœŸæ—¶é—´** - è®¾ç½® TTL å’ŒæŸ¥çœ‹å‰©ä½™æ—¶é—´
3. **è®¡æ•°å™¨** - åŸå­é€’å¢æ“ä½œ
4. **é™æµæ¼”ç¤º** - API è¯·æ±‚é™æµ
5. **ç¼“å­˜æµ‹è¯•** - æ•°æ®åº“æŸ¥è¯¢ç¼“å­˜

<Callout type="info" emoji="ğŸ”¬">
è¿™ä¸ªæ¼”ç¤ºé¡µé¢è¿æ¥çœŸå®çš„ Redis æœåŠ¡ï¼Œä½ å¯ä»¥çœ‹åˆ°å®é™…çš„ç¼“å­˜æ“ä½œæ•ˆæœã€‚
</Callout>

### API é™æµæ¼”ç¤º

è¯•è¯•è¿™ä¸ªé™æµ APIï¼š

```bash
# å¿«é€Ÿå‘é€å¤šä¸ªè¯·æ±‚æµ‹è¯•é™æµ
for i in {1..6}; do
  curl -X GET "http://localhost:3000/api/rate-limit-example" \
    -H "X-User-ID: test-user" && echo
done
```

## ç›‘æ§å’Œè°ƒè¯•

### 1. ç¼“å­˜å‘½ä¸­ç‡ç›‘æ§

```typescript filename="lib/cache-metrics.ts"
export class CacheMetrics {
  private static hits = 0
  private static misses = 0
  
  static recordHit() {
    this.hits++
  }
  
  static recordMiss() {
    this.misses++
  }
  
  static getStats() {
    const total = this.hits + this.misses
    const hitRate = total > 0 ? (this.hits / total) * 100 : 0
    
    return {
      hits: this.hits,
      misses: this.misses,
      total,
      hitRate: parseFloat(hitRate.toFixed(2))
    }
  }
  
  static reset() {
    this.hits = 0
    this.misses = 0
  }
}

// åœ¨ç¼“å­˜å·¥å…·ç±»ä¸­ä½¿ç”¨
export class CacheManager {
  static async get<T>(key: string): Promise<T | null> {
    try {
      const data = await redis.get(key)
      if (data !== null) {
        CacheMetrics.recordHit()
        return data as T
      } else {
        CacheMetrics.recordMiss()
        return null
      }
    } catch (error) {
      CacheMetrics.recordMiss()
      console.error('Redis get error:', error)
      return null
    }
  }
}
```

### 2. ç¼“å­˜è°ƒè¯•å·¥å…·

```typescript filename="lib/cache-debug.ts"
export class CacheDebug {
  static async inspectKey(key: string) {
    const [exists, ttl, type, value] = await Promise.all([
      CacheManager.exists(key),
      CacheManager.ttl(key),
      redis.type(key),
      CacheManager.get(key)
    ])
    
    return {
      key,
      exists,
      ttl: ttl === -1 ? 'æ°¸ä¸è¿‡æœŸ' : `${ttl} ç§’`,
      type,
      value: JSON.stringify(value, null, 2)
    }
  }
  
  static async listKeys(pattern: string = '*') {
    // æ³¨æ„ï¼šåœ¨ç”Ÿäº§ç¯å¢ƒä¸­è°¨æ…ä½¿ç”¨ KEYS å‘½ä»¤
    return await redis.keys(pattern)
  }
}
```

## æœ€ä½³å®è·µ

### 1. ç¼“å­˜é”®å‘½åè§„èŒƒ

```typescript
// å¥½çš„é”®å‘½åæ–¹å¼
const userKey = `user:${userId}`                    // user:123
const userPostsKey = `user:${userId}:posts`         // user:123:posts
const sessionKey = `session:${sessionId}`           // session:abc123
const rateLimitKey = `rate_limit:api:${ip}`         // rate_limit:api:192.168.1.1

// é¿å…çš„é”®å‘½åæ–¹å¼
const badKey1 = `user_${userId}_data`               // ä¸ä¸€è‡´çš„åˆ†éš”ç¬¦
const badKey2 = `userPosts${userId}`                // æ²¡æœ‰åˆ†éš”ç¬¦
const badKey3 = `user:${userId}:posts:${Date.now()}` // åŒ…å«æ—¶é—´æˆ³
```

### 2. é€‚å½“çš„ TTL è®¾ç½®

```typescript
const TTL_CONFIG = {
  // ç”¨æˆ·ä¿¡æ¯ - ç›¸å¯¹ç¨³å®š
  USER_PROFILE: 600,      // 10åˆ†é’Ÿ
  
  // æ–‡ç« å†…å®¹ - è¾ƒç¨³å®š
  POST_CONTENT: 1800,     // 30åˆ†é’Ÿ
  
  // æ–‡ç« åˆ—è¡¨ - ç»å¸¸å˜åŒ–
  POST_LIST: 300,         // 5åˆ†é’Ÿ
  
  // ç»Ÿè®¡æ•°æ® - å¯ä»¥ç¨æ—§
  STATISTICS: 3600,       // 1å°æ—¶
  
  // ä¼šè¯ä¿¡æ¯ - é•¿æœŸæœ‰æ•ˆ
  USER_SESSION: 7 * 24 * 60 * 60, // 7å¤©
  
  // éªŒè¯ç  - çŸ­æœŸæœ‰æ•ˆ
  VERIFICATION_CODE: 300,  // 5åˆ†é’Ÿ
}
```

### 3. é”™è¯¯å¤„ç†å’Œé™çº§

```typescript
export async function getUserWithFallback(userId: string) {
  try {
    // å°è¯•ä»ç¼“å­˜è·å–
    const cached = await CacheManager.get<User>(`user:${userId}`)
    if (cached) {
      return cached
    }
  } catch (error) {
    console.warn('Cache error, falling back to database:', error)
  }
  
  // ç¼“å­˜å¤±è´¥æˆ–æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“è·å–
  const user = await prisma.user.findUnique({
    where: { id: userId }
  })
  
  if (user) {
    // å°è¯•å†™å…¥ç¼“å­˜ï¼Œä½†ä¸é˜»å¡å“åº”
    CacheManager.set(`user:${userId}`, user, { ex: 600 }).catch(error => {
      console.warn('Failed to cache user data:', error)
    })
  }
  
  return user
}
```

## å¸¸è§é—®é¢˜

### Q: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨ç¼“å­˜ï¼Ÿ

A: ä»¥ä¸‹æƒ…å†µé€‚åˆä½¿ç”¨ç¼“å­˜ï¼š
- æŸ¥è¯¢é¢‘ç¹ä½†å˜åŒ–ä¸é¢‘ç¹çš„æ•°æ®
- è®¡ç®—å¤æ‚çš„ç»“æœ
- å¤–éƒ¨ API è°ƒç”¨ç»“æœ
- æ•°æ®åº“èšåˆæŸ¥è¯¢ç»“æœ
- ç”¨æˆ·ä¼šè¯ä¿¡æ¯

### Q: å¦‚ä½•é€‰æ‹©åˆé€‚çš„ TTLï¼Ÿ

A: TTL é€‰æ‹©åŸåˆ™ï¼š
- æ•°æ®æ›´æ–°é¢‘ç‡ï¼šæ›´æ–°è¶Šé¢‘ç¹ï¼ŒTTL è¶ŠçŸ­
- æ•°æ®é‡è¦æ€§ï¼šé‡è¦æ•°æ®å¯ä»¥è®¾ç½®è¾ƒçŸ­ TTL
- ä¸šåŠ¡å®¹å¿åº¦ï¼šä¸šåŠ¡èƒ½å®¹å¿å¤šä¹…çš„æ•°æ®å»¶è¿Ÿ
- èµ„æºæ¶ˆè€—ï¼šæŸ¥è¯¢æˆæœ¬é«˜çš„æ•°æ®å¯ä»¥è®¾ç½®è¾ƒé•¿ TTL

### Q: å¦‚ä½•å¤„ç†ç¼“å­˜å‡»ç©¿ï¼Ÿ

A: ä½¿ç”¨äº’æ–¥é”é˜²æ­¢ç¼“å­˜å‡»ç©¿ï¼š

```typescript
const lockKey = `lock:${cacheKey}`
const lockTTL = 10 // 10ç§’é”è¶…æ—¶

export async function getWithLock<T>(
  cacheKey: string,
  fetcher: () => Promise<T>,
  ttl: number = 300
): Promise<T> {
  // å°è¯•è·å–ç¼“å­˜
  let cached = await CacheManager.get<T>(cacheKey)
  if (cached !== null) {
    return cached
  }
  
  // å°è¯•è·å–é”
  const lockAcquired = await redis.set(lockKey, '1', { nx: true, ex: lockTTL })
  
  if (lockAcquired) {
    try {
      // è·å¾—é”ï¼Œä»æ•°æ®åº“åŠ è½½æ•°æ®
      const data = await fetcher()
      await CacheManager.set(cacheKey, data, { ex: ttl })
      return data
    } finally {
      // é‡Šæ”¾é”
      await CacheManager.del(lockKey)
    }
  } else {
    // æœªè·å¾—é”ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
    await new Promise(resolve => setTimeout(resolve, 50))
    cached = await CacheManager.get<T>(cacheKey)
    if (cached !== null) {
      return cached
    }
    
    // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ç¼“å­˜ï¼Œç›´æ¥æŸ¥è¯¢æ•°æ®åº“
    return await fetcher()
  }
}
```

## ä¸‹ä¸€æ­¥

- å­¦ä¹  [OSS æ–‡ä»¶å­˜å‚¨æ•™ç¨‹](/tutorials/oss) äº†è§£æ–‡ä»¶ä¸Šä¼ å’Œ CDN ç¼“å­˜
- æŸ¥çœ‹ [æ€§èƒ½ä¼˜åŒ–æ•™ç¨‹](/tutorials/performance) å­¦ä¹ æ›´å¤šä¼˜åŒ–æŠ€å·§
- æ¢ç´¢ [API è®¾è®¡æ•™ç¨‹](/tutorials/api-design) äº†è§£å¦‚ä½•è®¾è®¡é«˜æ€§èƒ½ API

