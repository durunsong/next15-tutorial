import { Callout, Steps, Tab, Tabs } from 'nextra/components';

# Prisma æ•°æ®åº“æ•™ç¨‹

<Callout type="info" emoji="â„¹ï¸">
  æœ¬æ•™ç¨‹å°†å¸¦ä½ æ·±å…¥äº†è§£ Prisma ORM çš„ä½¿ç”¨ï¼ŒåŒ…å«çœŸå®çš„æ•°æ®åº“æ“ä½œæ¼”ç¤ºã€‚
</Callout>

## ä»€ä¹ˆæ˜¯ Prismaï¼Ÿ

Prisma æ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„æ•°æ®åº“å·¥å…·åŒ…ï¼ŒåŒ…å«ï¼š

- **Prisma Client**: ç±»å‹å®‰å…¨çš„æ•°æ®åº“å®¢æˆ·ç«¯
- **Prisma Migrate**: æ•°æ®åº“è¿ç§»å·¥å…·
- **Prisma Studio**: æ•°æ®åº“å¯è§†åŒ–ç®¡ç†å·¥å…·

## é¡¹ç›®ä¸­çš„æ•°æ®åº“ç»“æ„

æˆ‘ä»¬çš„é¡¹ç›®ä½¿ç”¨ PostgreSQL æ•°æ®åº“ï¼ŒåŒ…å«ä»¥ä¸‹è¡¨ç»“æ„ï¼š

<Tabs items={['ç”¨æˆ·è¡¨', 'æ–‡ç« è¡¨', 'è¯„è®ºè¡¨', 'æ–‡ä»¶è¡¨']}>
  <Tab>
    ```prisma filename="schema.prisma" {3-22}
    model User {
      id        String    @id @default(cuid())
      email     String    @unique
      username  String    @unique
      password  String
      avatar    String?
      createdAt DateTime  @default(now())
      updatedAt DateTime  @updatedAt
      comments  Comment[]
      posts     Post[]

      @@map("users")
    }
    ```

  </Tab>
  <Tab>
    ```prisma filename="schema.prisma" {24-42}
    model Post {
      id         String    @id @default(cuid())
      title      String
      content    String
      published  Boolean   @default(false)
      category   String
      difficulty String
      tags       String[]
      coverImage String?
      views      Int       @default(0)
      likes      Int       @default(0)
      createdAt  DateTime  @default(now())
      updatedAt  DateTime  @updatedAt
      authorId   String
      comments   Comment[]
      author     User      @relation(fields: [authorId], references: [id], onDelete: Cascade)

      @@map("posts")
    }
    ```

  </Tab>
  <Tab>
    ```prisma filename="schema.prisma" {44-55}
    model Comment {
      id        String   @id @default(cuid())
      content   String
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt
      postId    String
      authorId  String
      author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
      post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

      @@map("comments")
    }
    ```

  </Tab>
  <Tab>
    ```prisma filename="schema.prisma" {57-68}
    model file_uploads {
      id           String   @id
      filename     String
      originalName String
      mimeType     String
      size         Int
      url          String
      bucket       String
      key          String
      uploadedBy   String?
      createdAt    DateTime @default(now())
    }
    ```
  </Tab>
</Tabs>

## åŸºç¡€æ“ä½œæ¼”ç¤º

### 1. åˆ›å»ºç”¨æˆ·

<Steps>

### å¯¼å…¥ Prisma å®¢æˆ·ç«¯

```typescript filename="lib/prisma.ts"
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

### åˆ›å»ºç”¨æˆ· API

```typescript filename="app/api/users/route.ts" {1,4-5,8-20}
import bcrypt from 'bcryptjs';

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/lib/prisma';

export async function POST(req: NextRequest) {
  try {
    const { email, username, password } = await req.json();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [{ email }, { username }],
      },
    });

    if (existingUser) {
      return NextResponse.json({ error: 'ç”¨æˆ·å·²å­˜åœ¨' }, { status: 400 });
    }

    // åŠ å¯†å¯†ç 
    const hashedPassword = await bcrypt.hash(password, 12);

    // åˆ›å»ºç”¨æˆ·
    const user = await prisma.user.create({
      data: {
        email,
        username,
        password: hashedPassword,
      },
      select: {
        id: true,
        email: true,
        username: true,
        createdAt: true,
      },
    });

    return NextResponse.json(user, { status: 201 });
  } catch (error) {
    console.error('åˆ›å»ºç”¨æˆ·å¤±è´¥:', error);
    return NextResponse.json({ error: 'æœåŠ¡å™¨é”™è¯¯' }, { status: 500 });
  }
}
```

### æµ‹è¯•åˆ›å»ºç”¨æˆ·

ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æµ‹è¯•ç”¨æˆ·åˆ›å»ºï¼š

```bash
curl -X POST http://localhost:3000/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "username": "testuser",
    "password": "password123"
  }'
```

</Steps>

### 2. æŸ¥è¯¢ç”¨æˆ·

<Tabs items={['è·å–æ‰€æœ‰ç”¨æˆ·', 'æ ¹æ® ID æŸ¥è¯¢', 'åˆ†é¡µæŸ¥è¯¢']}>
  <Tab>
    ```typescript filename="app/api/users/route.ts"
    export async function GET() {
      try {
        const users = await prisma.user.findMany({
          select: {
            id: true,
            email: true,
            username: true,
            avatar: true,
            createdAt: true,
            _count: {
              select: {
                posts: true,
                comments: true,
              }
            }
          },
          orderBy: {
            createdAt: 'desc'
          }
        })
        
        return NextResponse.json(users)
      } catch (error) {
        console.error('æŸ¥è¯¢ç”¨æˆ·å¤±è´¥:', error)
        return NextResponse.json(
          { error: 'æœåŠ¡å™¨é”™è¯¯' },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>
  <Tab>
    ```typescript filename="app/api/users/[id]/route.ts"
    export async function GET(
      req: NextRequest,
      { params }: { params: { id: string } }
    ) {
      try {
        const user = await prisma.user.findUnique({
          where: { id: params.id },
          include: {
            posts: {
              take: 5,
              orderBy: { createdAt: 'desc' },
              select: {
                id: true,
                title: true,
                createdAt: true,
                views: true,
                likes: true,
              }
            },
            _count: {
              select: {
                posts: true,
                comments: true,
              }
            }
          }
        })
        
        if (!user) {
          return NextResponse.json(
            { error: 'ç”¨æˆ·ä¸å­˜åœ¨' },
            { status: 404 }
          )
        }
        
        // ä¸è¿”å›å¯†ç 
        const { password, ...userWithoutPassword } = user
        return NextResponse.json(userWithoutPassword)
      } catch (error) {
        console.error('æŸ¥è¯¢ç”¨æˆ·å¤±è´¥:', error)
        return NextResponse.json(
          { error: 'æœåŠ¡å™¨é”™è¯¯' },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>
  <Tab>
    ```typescript filename="app/api/users/route.ts"
    export async function GET(req: NextRequest) {
      try {
        const { searchParams } = new URL(req.url)
        const page = parseInt(searchParams.get('page') || '1')
        const limit = parseInt(searchParams.get('limit') || '10')
        const skip = (page - 1) * limit
        
        const [users, total] = await Promise.all([
          prisma.user.findMany({
            skip,
            take: limit,
            select: {
              id: true,
              email: true,
              username: true,
              avatar: true,
              createdAt: true,
            },
            orderBy: {
              createdAt: 'desc'
            }
          }),
          prisma.user.count()
        ])
        
        return NextResponse.json({
          users,
          pagination: {
            page,
            limit,
            total,
            pages: Math.ceil(total / limit)
          }
        })
      } catch (error) {
        console.error('æŸ¥è¯¢ç”¨æˆ·å¤±è´¥:', error)
        return NextResponse.json(
          { error: 'æœåŠ¡å™¨é”™è¯¯' },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>
</Tabs>

## é«˜çº§æŸ¥è¯¢æŠ€å·§

### 1. å…³è”æŸ¥è¯¢

```typescript filename="ä¾‹å­ï¼šè·å–ç”¨æˆ·åŠå…¶æ–‡ç« "
const userWithPosts = await prisma.user.findUnique({
  where: { id: userId },
  include: {
    posts: {
      where: { published: true },
      include: {
        comments: {
          take: 3,
          orderBy: { createdAt: 'desc' },
          include: {
            author: {
              select: {
                username: true,
                avatar: true,
              },
            },
          },
        },
        _count: {
          select: {
            comments: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    },
  },
});
```

### 2. èšåˆæŸ¥è¯¢

```typescript filename="ä¾‹å­ï¼šç»Ÿè®¡æ•°æ®"
const statistics = await prisma.user.aggregate({
  _count: {
    id: true,
  },
  _avg: {
    posts: {
      _count: {
        select: {
          comments: true,
        },
      },
    },
  },
});

// æˆ–è€…ä½¿ç”¨ groupBy
const usersByMonth = await prisma.user.groupBy({
  by: ['createdAt'],
  _count: {
    id: true,
  },
  orderBy: {
    createdAt: 'asc',
  },
});
```

### 3. äº‹åŠ¡æ“ä½œ

<Callout type="warning" emoji="âš ï¸">
  åœ¨è¿›è¡Œæ‰¹é‡æ“ä½œæˆ–éœ€è¦ä¿è¯æ•°æ®ä¸€è‡´æ€§æ—¶ï¼ŒåŠ¡å¿…ä½¿ç”¨äº‹åŠ¡ã€‚
</Callout>

```typescript filename="ä¾‹å­ï¼šåˆ›å»ºæ–‡ç« å’Œé€šçŸ¥"
const result = await prisma.$transaction(async tx => {
  // åˆ›å»ºæ–‡ç« 
  const post = await tx.post.create({
    data: {
      title: 'æ–°æ–‡ç« ',
      content: 'æ–‡ç« å†…å®¹',
      authorId: userId,
      category: 'æŠ€æœ¯',
      difficulty: 'åˆçº§',
    },
  });

  // æ›´æ–°ç”¨æˆ·æ–‡ç« æ•°é‡ï¼ˆå¦‚æœæœ‰ç›¸å…³è®¡æ•°å­—æ®µï¼‰
  const updatedUser = await tx.user.update({
    where: { id: userId },
    data: {
      // å‡è®¾æœ‰ postsCount å­—æ®µ
      // postsCount: { increment: 1 }
    },
  });

  return { post, user: updatedUser };
});
```

## æ€§èƒ½ä¼˜åŒ–

### 1. é€‰æ‹©å­—æ®µ

```typescript
// âŒ ä¸å¥½çš„åšæ³• - è·å–æ‰€æœ‰å­—æ®µ
const users = await prisma.user.findMany()

// âœ… å¥½çš„åšæ³• - åªé€‰æ‹©éœ€è¦çš„å­—æ®µ
const users = await prisma.user.findMany({
  select: {
    id: true,
    username: true,
    email: true,
  }
})
```

### 2. åˆ†é¡µæŸ¥è¯¢

```typescript
// âœ… ä½¿ç”¨ cursor-based åˆ†é¡µï¼ˆæ¨èç”¨äºå¤§æ•°æ®é›†ï¼‰
const posts = await prisma.post.findMany({
  take: 10,
  cursor: lastPostId ? { id: lastPostId } : undefined,
  skip: lastPostId ? 1 : 0,
  orderBy: { createdAt: 'desc' }
})

// âœ… ä½¿ç”¨ offset-based åˆ†é¡µï¼ˆé€‚ç”¨äºå°æ•°æ®é›†ï¼‰
const posts = await prisma.post.findMany({
  skip: (page - 1) * limit,
  take: limit,
  orderBy: { createdAt: 'desc' }
})
```

### 3. æ•°æ®åº“ç´¢å¼•

ç¡®ä¿åœ¨ schema.prisma ä¸­ä¸ºç»å¸¸æŸ¥è¯¢çš„å­—æ®µæ·»åŠ ç´¢å¼•ï¼š

```prisma filename="schema.prisma"
model Post {
  id        String   @id @default(cuid())
  title     String
  category  String
  published Boolean  @default(false)
  authorId  String
  createdAt DateTime @default(now())

  // æ·»åŠ ç´¢å¼•
  @@index([category])
  @@index([published])
  @@index([authorId])
  @@index([createdAt])
}
```

## çœŸå®æ¼”ç¤º

è®¿é—®ä»¥ä¸‹é¡µé¢æŸ¥çœ‹çœŸå®çš„æ•°æ®åº“æ“ä½œæ¼”ç¤ºï¼š

- [æ•°æ®åº“ç®¡ç†é¡µé¢](/database) - æŸ¥çœ‹å’Œç®¡ç†ç”¨æˆ·ã€æ–‡ç« æ•°æ®
- [ç”¨æˆ·æ³¨å†Œæ¼”ç¤º](/auth/register) - å®é™…çš„ç”¨æˆ·åˆ›å»ºæµç¨‹
- [æ–‡ç« ç®¡ç†æ¼”ç¤º](/posts) - æ–‡ç« çš„ CRUD æ“ä½œ

<Callout type="info" emoji="ğŸ’¡">
  è¿™äº›æ¼”ç¤ºé¡µé¢è¿æ¥çœŸå®çš„ PostgreSQL æ•°æ®åº“ï¼Œä½ å¯ä»¥çœ‹åˆ°å®é™…çš„æ•°æ®æ“ä½œæ•ˆæœã€‚
</Callout>

## å¸¸è§é—®é¢˜

### Q: å¦‚ä½•å¤„ç†æ•°æ®åº“è¿æ¥ï¼Ÿ

A: Prisma Client ä¼šè‡ªåŠ¨ç®¡ç†è¿æ¥æ± ï¼Œä½†åœ¨ serverless ç¯å¢ƒä¸­å»ºè®®ä½¿ç”¨å•ä¾‹æ¨¡å¼ï¼š

```typescript filename="lib/prisma.ts"
import { PrismaClient } from '@prisma/client';

declare global {
  var __prisma: PrismaClient | undefined;
}

const prisma = globalThis.__prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalThis.__prisma = prisma;

export default prisma;
```

### Q: å¦‚ä½•å¤„ç†æ•°æ®éªŒè¯ï¼Ÿ

A: å»ºè®®ç»“åˆ Zod è¿›è¡Œæ•°æ®éªŒè¯ï¼š

```typescript
import { z } from 'zod';

const createUserSchema = z.object({
  email: z.string().email(),
  username: z.string().min(3).max(20),
  password: z.string().min(6),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { email, username, password } = createUserSchema.parse(body);

    // ç»§ç»­å¤„ç†...
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'æ•°æ®éªŒè¯å¤±è´¥', details: error.errors }, { status: 400 });
    }
    // å¤„ç†å…¶ä»–é”™è¯¯...
  }
}
```

## ä¸‹ä¸€æ­¥

- å­¦ä¹  [Redis ç¼“å­˜æ•™ç¨‹](/tutorials/redis) æ¥ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½
- æŸ¥çœ‹ [API è®¾è®¡æ•™ç¨‹](/tutorials/api-design) äº†è§£æ›´å¤š API æœ€ä½³å®è·µ
- æ¢ç´¢ [æ€§èƒ½ä¼˜åŒ–æ•™ç¨‹](/tutorials/performance) æå‡åº”ç”¨æ€§èƒ½
